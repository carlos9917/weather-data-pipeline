<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Carlos Peralta">
<meta name="dcterms.date" content="2025-09-04">

<title>Wind Gust Parameterization Methods: A Review and Implementation Analysis</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="wind_gust_calculation_files/libs/clipboard/clipboard.min.js"></script>
<script src="wind_gust_calculation_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="wind_gust_calculation_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="wind_gust_calculation_files/libs/quarto-html/popper.min.js"></script>
<script src="wind_gust_calculation_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="wind_gust_calculation_files/libs/quarto-html/anchor.min.js"></script>
<link href="wind_gust_calculation_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="wind_gust_calculation_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="wind_gust_calculation_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="wind_gust_calculation_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="wind_gust_calculation_files/libs/bootstrap/bootstrap-9c15a5338fb2cec66ee684ebdf9d454e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#wind-gust-parameterization-methods-review" id="toc-wind-gust-parameterization-methods-review" class="nav-link" data-scroll-target="#wind-gust-parameterization-methods-review"><span class="header-section-number">2</span> Wind Gust Parameterization Methods Review</a>
  <ul class="collapse">
  <li><a href="#sec-power-law" id="toc-sec-power-law" class="nav-link" data-scroll-target="#sec-power-law"><span class="header-section-number">2.1</span> Power Law Method</a>
  <ul class="collapse">
  <li><a href="#theoretical-foundation" id="toc-theoretical-foundation" class="nav-link" data-scroll-target="#theoretical-foundation"><span class="header-section-number">2.1.1</span> Theoretical Foundation</a></li>
  <li><a href="#power-law-exponent-determination" id="toc-power-law-exponent-determination" class="nav-link" data-scroll-target="#power-law-exponent-determination"><span class="header-section-number">2.1.2</span> Power Law Exponent Determination</a></li>
  <li><a href="#implementation-approach" id="toc-implementation-approach" class="nav-link" data-scroll-target="#implementation-approach"><span class="header-section-number">2.1.3</span> Implementation Approach</a></li>
  <li><a href="#key-characteristics" id="toc-key-characteristics" class="nav-link" data-scroll-target="#key-characteristics"><span class="header-section-number">2.1.4</span> Key Characteristics</a></li>
  <li><a href="#performance-characteristics" id="toc-performance-characteristics" class="nav-link" data-scroll-target="#performance-characteristics"><span class="header-section-number">2.1.5</span> Performance Characteristics</a></li>
  </ul></li>
  <li><a href="#sec-w73" id="toc-sec-w73" class="nav-link" data-scroll-target="#sec-w73"><span class="header-section-number">2.2</span> Wieringa (1973) Method</a>
  <ul class="collapse">
  <li><a href="#theoretical-foundation-1" id="toc-theoretical-foundation-1" class="nav-link" data-scroll-target="#theoretical-foundation-1"><span class="header-section-number">2.2.1</span> Theoretical Foundation</a></li>
  <li><a href="#key-characteristics-1" id="toc-key-characteristics-1" class="nav-link" data-scroll-target="#key-characteristics-1"><span class="header-section-number">2.2.2</span> Key Characteristics</a></li>
  </ul></li>
  <li><a href="#sec-wnp01" id="toc-sec-wnp01" class="nav-link" data-scroll-target="#sec-wnp01"><span class="header-section-number">2.3</span> Woetman Nielsen and Petersen (2001) Method</a>
  <ul class="collapse">
  <li><a href="#theoretical-foundation-2" id="toc-theoretical-foundation-2" class="nav-link" data-scroll-target="#theoretical-foundation-2"><span class="header-section-number">2.3.1</span> Theoretical Foundation</a></li>
  <li><a href="#key-characteristics-2" id="toc-key-characteristics-2" class="nav-link" data-scroll-target="#key-characteristics-2"><span class="header-section-number">2.3.2</span> Key Characteristics</a></li>
  </ul></li>
  <li><a href="#sec-suomi" id="toc-sec-suomi" class="nav-link" data-scroll-target="#sec-suomi"><span class="header-section-number">2.4</span> Suomi et al.&nbsp;(2013) Method</a>
  <ul class="collapse">
  <li><a href="#theoretical-foundation-3" id="toc-theoretical-foundation-3" class="nav-link" data-scroll-target="#theoretical-foundation-3"><span class="header-section-number">2.4.1</span> Theoretical Foundation</a></li>
  <li><a href="#key-characteristics-3" id="toc-key-characteristics-3" class="nav-link" data-scroll-target="#key-characteristics-3"><span class="header-section-number">2.4.2</span> Key Characteristics</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#practical-implementation" id="toc-practical-implementation" class="nav-link" data-scroll-target="#practical-implementation"><span class="header-section-number">3</span> Practical implementation</a>
  <ul class="collapse">
  <li><a href="#spatial-validation-analysis" id="toc-spatial-validation-analysis" class="nav-link" data-scroll-target="#spatial-validation-analysis"><span class="header-section-number">3.1</span> Spatial Validation Analysis</a>
  <ul class="collapse">
  <li><a href="#methodological-improvements" id="toc-methodological-improvements" class="nav-link" data-scroll-target="#methodological-improvements"><span class="header-section-number">3.1.1</span> Methodological Improvements</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">4</span> Summary</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references"><span class="header-section-number">5</span> References</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Wind Gust Parameterization Methods: A Review and Implementation Analysis</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Carlos Peralta </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 4, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>Wind gust forecasting is critical for wind energy applications, aviation safety, and structural engineering. Traditional parameterization methods were developed for the standard 10-meter reference height, but for example in wind energy modern wind turbines operate at hub heights of 100+ meters, necessitating new approaches that account for height-dependent effects, atmospheric stability, and surface roughness variations.</p>
<p>This documents outlines different methods to answer the technical question:</p>
<pre><code>How would you calculate wind gusts based on the weather model output?
Outline your approach to deriving gusts (e.g. using 10 m wind, boundary layer turbulence
diagnostics), including any assumptions or approximations.</code></pre>
<p>Most numerical weather models provide a post-processed wind gust estimate. The data downloaded in the data pipeline developed in this repository includes wind gust from a global (GFS) and a high resolution regional model (MET).</p>
<p>The kind of parametrization used for estimating wind gust at the surface varies with the numerical model. They range from using a simple (empirical) multiplicative factor to more sophisticated formulas that consider atmospheric stability. Below we review wind gust parameterization methods discussed in Suomi et al.&nbsp;(2013) and analyzes their implementation. The analysis covers three main parameterization approaches: Wieringa (1973), Woetman Nielsen and Petersen (2001), and the more recent Suomi method.</p>
<p>A python script that implements the simplest of the approaches can also be found in <code>data_processing/calculate_wind_gust.py</code>.</p>
</section>
<section id="wind-gust-parameterization-methods-review" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Wind Gust Parameterization Methods Review</h1>
<section id="sec-power-law" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="sec-power-law"><span class="header-section-number">2.1</span> Power Law Method</h2>
<section id="theoretical-foundation" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="theoretical-foundation"><span class="header-section-number">2.1.1</span> Theoretical Foundation</h3>
<p>The power law method represents the simplest approach to wind gust parameterization, based on the classical wind profile relationship:</p>
<p><span class="math display">\[u(z) = u_{ref} \left(\frac{z}{z_{ref}}\right)^{\alpha}\]</span></p>
<p>Where:</p>
<ul>
<li><p><span class="math inline">\(u(z)\)</span> = wind speed at height <span class="math inline">\(z\)</span></p></li>
<li><p><span class="math inline">\(u_{ref}\)</span> = reference wind speed at reference height <span class="math inline">\(z_{ref}\)</span></p></li>
<li><p><span class="math inline">\(\alpha\)</span> = power law exponent (typically 0.1-0.4)</p></li>
</ul>
<p>For gust calculations, the method applies the same scaling to both mean wind and gust components:</p>
<p><span class="math display">\[G(z) = G_{ref} \left(\frac{z}{z_{ref}}\right)^{\alpha}\]</span></p>
</section>
<section id="power-law-exponent-determination" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="power-law-exponent-determination"><span class="header-section-number">2.1.2</span> Power Law Exponent Determination</h3>
<p>The exponent <span class="math inline">\(\alpha\)</span> varies with:</p>
<p><strong>Surface roughness:</strong> - Smooth surfaces (water, ice): <span class="math inline">\(\alpha \approx 0.1\)</span> - Open terrain (grassland): <span class="math inline">\(\alpha \approx 0.15\)</span> - Suburban areas: <span class="math inline">\(\alpha \approx 0.25\)</span> - Urban/forest: <span class="math inline">\(\alpha \approx 0.3-0.4\)</span></p>
<p><strong>Atmospheric stability:</strong> - Unstable conditions: <span class="math inline">\(\alpha\)</span> decreases (enhanced mixing) - Stable conditions: <span class="math inline">\(\alpha\)</span> increases (reduced mixing) - Neutral conditions: Standard values apply</p>
</section>
<section id="implementation-approach" class="level3" data-number="2.1.3">
<h3 data-number="2.1.3" class="anchored" data-anchor-id="implementation-approach"><span class="header-section-number">2.1.3</span> Implementation Approach</h3>
<p>The power law gust parameterization follows these steps:</p>
<ol type="1">
<li><strong>Reference gust calculation</strong> at standard height (typically 10m)</li>
<li><strong>Height extrapolation</strong> using appropriate power law exponent</li>
<li><strong>Roughness adjustment</strong> based on local surface characteristics</li>
<li><strong>Optional stability correction</strong> for improved accuracy</li>
</ol>
</section>
<section id="key-characteristics" class="level3" data-number="2.1.4">
<h3 data-number="2.1.4" class="anchored" data-anchor-id="key-characteristics"><span class="header-section-number">2.1.4</span> Key Characteristics</h3>
<p><strong>Strengths:</strong></p>
<ul>
<li><strong>Computational simplicity</strong> - minimal processing requirements</li>
<li><strong>Widely understood</strong> - established meteorological practice</li>
<li><strong>Baseline reference</strong> - useful for method comparison</li>
<li><strong>Data requirements minimal</strong> - only reference wind speed needed</li>
</ul>
<p><strong>Limitations:</strong></p>
<ul>
<li><strong>Systematic underestimation</strong> of gust wind speeds at higher elevations</li>
<li><strong>No stability effects</strong> - assumes neutral atmospheric conditions</li>
<li><strong>Limited height range</strong> - accuracy decreases significantly above 50-100m</li>
<li><strong>Oversimplified physics</strong> - ignores turbulence generation mechanisms</li>
<li><strong>Site-specific bias</strong> - requires local calibration for accuracy</li>
</ul>
</section>
<section id="performance-characteristics" class="level3" data-number="2.1.5">
<h3 data-number="2.1.5" class="anchored" data-anchor-id="performance-characteristics"><span class="header-section-number">2.1.5</span> Performance Characteristics</h3>
<p>Observational studies have shown that the power law method:</p>
<ul>
<li><strong>Underestimates gusts</strong> by 10-30% at wind energy heights (80-150m)</li>
<li><strong>Shows largest errors</strong> in stable atmospheric conditions</li>
<li><strong>Performs reasonably</strong> in neutral conditions over simple terrain</li>
<li><strong>Requires bias correction</strong> for operational applications</li>
</ul>
</section>
</section>
<section id="sec-w73" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="sec-w73"><span class="header-section-number">2.2</span> Wieringa (1973) Method</h2>
<section id="theoretical-foundation-1" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="theoretical-foundation-1"><span class="header-section-number">2.2.1</span> Theoretical Foundation</h3>
<p>The W73 method represents one of the earliest systematic approaches to gust parameterization, based on the fundamental relationship:</p>
<p><span class="math display">\[G_{t,T} = 1 + \frac{g_{t,T} \cdot u_* \cdot t}{u_T \cdot \ln(z/z_0)}\]</span></p>
<p>Where:</p>
<ul>
<li><p><span class="math inline">\(G_{t,T}\)</span> = gust factor (ratio of gust to mean wind speed)</p></li>
<li><p><span class="math inline">\(g_{t,T}\)</span> = normalized gust coefficient</p></li>
<li><p><span class="math inline">\(u_*\)</span> = friction velocity</p></li>
<li><p><span class="math inline">\(t\)</span> = gust duration</p></li>
<li><p><span class="math inline">\(u_T\)</span> = mean wind speed over period T</p></li>
<li><p><span class="math inline">\(z\)</span> = height above surface</p></li>
<li><p><span class="math inline">\(z_0\)</span> = aerodynamic roughness length</p></li>
</ul>
</section>
<section id="key-characteristics-1" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="key-characteristics-1"><span class="header-section-number">2.2.2</span> Key Characteristics</h3>
<p><strong>Strengths:</strong></p>
<ul>
<li><strong>Computational simplicity</strong> - minimal processing requirements and easy implementation</li>
<li><strong>Well-established empirical basis</strong> - extensively validated across multiple sites</li>
<li><strong>Direct roughness incorporation</strong> - explicitly accounts for surface roughness effects</li>
<li><strong>Robust performance</strong> - reliable in near-neutral conditions up to ~50m height</li>
<li><strong>Minimal data requirements</strong> - only needs basic meteorological parameters</li>
<li><strong>Historical validation</strong> - proven track record in operational applications</li>
</ul>
<p><strong>Limitations:</strong></p>
<ul>
<li><strong>Neutral stability assumption</strong> - ignores important atmospheric stability effects</li>
<li><strong>Limited height range</strong> - accuracy decreases significantly above 50m elevation</li>
<li><strong>No stability dependence</strong> - cannot capture stability-driven gust variations</li>
<li><strong>Single-station derivation</strong> - limited geographical representativeness</li>
<li><strong>Overestimation in complex terrain</strong> - tends to overpredict gusts over forests</li>
<li><strong>Low wind speed issues</strong> - poor performance in weak wind conditions</li>
</ul>
</section>
</section>
<section id="sec-wnp01" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="sec-wnp01"><span class="header-section-number">2.3</span> Woetman Nielsen and Petersen (2001) Method</h2>
<section id="theoretical-foundation-2" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="theoretical-foundation-2"><span class="header-section-number">2.3.1</span> Theoretical Foundation</h3>
<p>The WNP01 method introduced atmospheric stability effects through the formulation:</p>
<p><span class="math display">\[G_{t,T} = 1 + g_{t,T} \left[ \gamma_0 \frac{c_N u_{*0}}{u_T} + (1-\gamma_0) \frac{c_B w_*}{u_T} \right]\]</span></p>
<p>Where:</p>
<ul>
<li><p><span class="math inline">\(\gamma_0 = 1 - \gamma_s\)</span> (stability parameter)</p></li>
<li><p><span class="math inline">\(\gamma_s = 1\)</span> for stable, <span class="math inline">\(\gamma_s = 0\)</span> for unstable conditions</p></li>
<li><p><span class="math inline">\(u_{*0}\)</span> = surface friction velocity</p></li>
<li><p><span class="math inline">\(w_* = (B_p h)^{1/3}\)</span> = convective velocity scale</p></li>
<li><p><span class="math inline">\(c_N, c_B\)</span> = empirical constants</p></li>
<li><p><span class="math inline">\(h\)</span> = boundary layer height</p></li>
</ul>
</section>
<section id="key-characteristics-2" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2" class="anchored" data-anchor-id="key-characteristics-2"><span class="header-section-number">2.3.2</span> Key Characteristics</h3>
<p><strong>Strengths:</strong></p>
<ul>
<li><p>Explicit stability dependence</p></li>
<li><p>Accounts for both mechanical and thermal turbulence</p></li>
<li><p>Physically-based approach using similarity theory</p></li>
<li><p>Applicable to various atmospheric conditions</p></li>
</ul>
<p><strong>Limitations:</strong></p>
<ul>
<li><p>Complex parameter determination</p></li>
<li><p>Requires boundary layer height information</p></li>
<li><p>Overestimates stability effects in some conditions</p></li>
<li><p>Limited validation at wind energy heights</p></li>
</ul>
</section>
</section>
<section id="sec-suomi" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="sec-suomi"><span class="header-section-number">2.4</span> Suomi et al.&nbsp;(2013) Method</h2>
<section id="theoretical-foundation-3" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1" class="anchored" data-anchor-id="theoretical-foundation-3"><span class="header-section-number">2.4.1</span> Theoretical Foundation</h3>
<p>The Suomi method represents a significant advancement in gust parameterization, combining turbulence intensity concepts with stability-dependent formulations specifically designed for wind energy heights:</p>
<p><span class="math display">\[G_{t,T} = 1 + g_{t,T} \frac{\sigma_U}{u_T}\]</span></p>
<p>Where the standard deviation of horizontal wind speed <span class="math inline">\(\sigma_U\)</span> is parameterized using modified Gryning et al.&nbsp;(1987) formulations:</p>
<p><strong>For unstable conditions:</strong> <span class="math display">\[\sigma_U = u_* \sqrt{c_1^2 + c_2^2 \left(\frac{z}{h}\right)^{2/3} \left(-\frac{h}{L}\right)^{2/3}}\]</span></p>
<p><strong>For stable conditions:</strong> <span class="math display">\[\sigma_U = u_* \sqrt{c_3^2 + c_4^2 \frac{z}{L}}\]</span></p>
<p>Where: - <span class="math inline">\(g_{t,T}\)</span> = normalized gust factor (observationally derived) - <span class="math inline">\(u_*\)</span> = friction velocity - <span class="math inline">\(h\)</span> = boundary layer height<br>
- <span class="math inline">\(L\)</span> = Obukhov length - <span class="math inline">\(z\)</span> = height above surface - <span class="math inline">\(c_1, c_2, c_3, c_4\)</span> = empirical constants</p>
</section>
<section id="key-characteristics-3" class="level3" data-number="2.4.2">
<h3 data-number="2.4.2" class="anchored" data-anchor-id="key-characteristics-3"><span class="header-section-number">2.4.2</span> Key Characteristics</h3>
<p><strong>Strengths:</strong></p>
<ul>
<li><strong>Superior performance</strong> - outperformed W73 and WNP01 methods in validation studies</li>
<li><strong>Height-explicit formulation</strong> - applicable from 30-143m, suitable for modern wind turbines</li>
<li><strong>Realistic stability effects</strong> - avoids overestimation issues of WNP01 method</li>
<li><strong>Unified approach</strong> - single framework for all stability conditions</li>
<li><strong>Observational basis</strong> - derived from extensive mast observations in different environments</li>
<li><strong>Physical insight</strong> - based on turbulence intensity concepts</li>
<li><strong>Flexible parameterization</strong> - adaptable to various surface roughness conditions</li>
</ul>
<p><strong>Limitations:</strong></p>
<ul>
<li><strong>Complex implementation</strong> - requires multiple meteorological parameters (u*, h, L)</li>
<li><strong>Boundary layer height dependency</strong> - sensitive to BL height accuracy in model applications</li>
<li><strong>Limited extreme conditions</strong> - validation focused on moderate to strong winds (&gt;3-5 m/s)</li>
<li><strong>Site-specific coefficients</strong> - normalized gust factors may vary between locations</li>
<li><strong>Computational requirements</strong> - more demanding than simpler methods like W73</li>
<li><strong>Parameter uncertainty</strong> - performance depends on accurate estimation of stability parameters</li>
</ul>
</section>
</section>
</section>
<section id="practical-implementation" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Practical implementation</h1>
<p>All the methods describe above require site specific parameters</p>
<p>In order to test them in different situations one would need:</p>
<ol type="1">
<li><p><strong>Historical data window</strong>: 1-2 months of measurements and weather model data</p></li>
<li><p><strong>Parameter fitting</strong>: Site-specific coefficient adjustment</p></li>
<li><p><strong>Stability classification</strong>: Separate parameters for different atmospheric conditions</p></li>
<li><p><strong>Seasonal variation</strong>: Accounting for annual cycles would require several months of data</p></li>
</ol>
<p>Additionally, since all model data has biases for different variables a simple bias correction approach could be included:</p>
<p>Use a <strong>lead-time dependent bias correction</strong>:</p>
<p><span class="math display">\[u_{gust,corrected} = a \cdot u_{gust,forecast} + b\]</span></p>
<p>Where coefficients <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> vary with forecast lead time.</p>
<p>This method can be effective for systematically biased predictions.</p>
<section id="spatial-validation-analysis" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="spatial-validation-analysis"><span class="header-section-number">3.1</span> Spatial Validation Analysis</h2>
<ul>
<li>Do a multi-Site Performance</li>
<li>Include both inland and coastal locations</li>
<li>Consider complex and flat terrains</li>
</ul>
<section id="methodological-improvements" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="methodological-improvements"><span class="header-section-number">3.1.1</span> Methodological Improvements</h3>
<ul>
<li><strong>Machine learning integration</strong> for parameter optimization</li>
<li><strong>High-resolution model</strong> for complex terrain</li>
<li><strong>Uncertainty quantification</strong> using ensemble forecast data</li>
</ul>
</section>
</section>
</section>
<section id="summary" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Summary</h1>
<p>Different methods can be used to estimate wind gust based on model output data. All the parametrizations listed above require site specific parameters and some bias correction of model output.</p>
<p><strong>Power Law Method:</strong> Simple but systematically underestimates gusts at wind energy heights. Best suited as a baseline reference method.</p>
<p><strong>Wieringa (1973):</strong> Although very simple, performs reasonably well in near-neutral conditions up to ~50m height. However, it tends to overestimate gust factors in complex or forested terrain and lacks stability dependence.</p>
<p><strong>Woetman Nielsen and Petersen (2001):</strong> Introduces important stability effects but tends to overestimate the effects of atmospheric stability, particularly in unstable conditions over rough surfaces. Complex parameter determination limits practical application.</p>
<p><strong>Suomi et al.&nbsp;(2013):</strong> Demonstrates superior performance across different stability conditions and surface types. The method successfully captures height dependence, stability effects, and surface roughness impacts without the overestimation issues of WNP01. Recommended for wind energy applications despite higher computational requirements.</p>
</section>
<section id="references" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> References</h1>
<p>Suomi, I., Vihma, T., Gryning, S. E., &amp; Fortelius, C. (2013). Wind-gust parametrizations at heights relevant for wind energy: a study based on mast observations. <em>Quarterly Journal of the Royal Meteorological Society</em>, 139(674), 1298-1310. https://doi.org/10.1002/qj.2039</p>
<p>Wieringa, J. (1973). Gust factors over open water and built-up country. <em>Boundary-Layer Meteorology</em>, 3(4), 424-441. https://doi.org/10.1007/BF01034986</p>
<p>Woetmann Nielsen, N., &amp; Petersen, C. (2001). Calculation of wind gusts in DMI-HIRLAM. <em>Danish Meteorological Institute Scientific Report</em>, 01-03.</p>
<p>Brasseur, O. (2001). Development and application of a physical approach to estimating wind gusts. <em>Monthly Weather Review</em>, 129(1), 5-25. https://doi.org/10.1175/1520-0493(2001)129&lt;0005:DAAOAP&gt;2.0.CO;2</p>
<p>Panofsky, H. A., &amp; Dutton, J. A. (1984). <em>Atmospheric Turbulence: Models and Methods for Engineering Applications</em>. John Wiley &amp; Sons.</p>
<p>Stull, R. B. (1988). <em>An Introduction to Boundary Layer Meteorology</em>. Kluwer Academic Publishers.</p>
<p>Kaimal, J. C., &amp; Finnigan, J. J. (1994). <em>Atmospheric Boundary Layer Flows: Their Structure and Measurement</em>. Oxford University Press.</p>
<p>Holtslag, A. A. M., &amp; Nieuwstadt, F. T. M. (1986). Scaling the atmospheric boundary layer. <em>Boundary-Layer Meteorology</em>, 36(3), 201-209. https://doi.org/10.1007/BF00118662</p>
<p>Gryning, S. E., Batchvarova, E., Brümmer, B., Jørgensen, H., &amp; Larsen, S. (2007). On the extension of the wind profile over homogeneous terrain beyond the surface boundary layer. <em>Boundary-Layer Meteorology</em>, 124(2), 251-268. https://doi.org/10.1007/s10546-007-9166-9</p>
<p>Floors, R., Peña, A., &amp; Gryning, S. E. (2015). The effect of baroclinicity on the wind in the planetary boundary layer. <em>Quarterly Journal of the Royal Meteorological Society</em>, 141(687), 619-630. https://doi.org/10.1002/qj.2386</p>
<hr>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>